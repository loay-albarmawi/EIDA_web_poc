import {
    Response,
    Result,
    TextFieldType,
    MeasureSystem,
    DocumentFormat,
    MRZFormat,
    ContainerList,
} from '@regulaforensics/document-reader-webclient';

interface DeviceInfo {
    reader_ready: boolean;
    rfid_ready: boolean;
    rfid_model_id: number;
}

type ErrorTypes =
    | 'WASM_ERROR'
    | 'WASM_LICENSE'
    | 'FILE_SIZE'
    | 'INCORRECT_FILE'
    | 'INCORRECT_SCENARIO'
    | 'UNKNOWN_ERROR'
    | 'NOT_SUPPORTED'
    | 'CAMERA_UNKNOWN_ERROR'
    | 'CAMERA_PERMISSION_DENIED'
    | 'NO_CAMERA'
    | 'INCORRECT_CAMERA_ID'
    | 'CONNECTION_ERROR';

type DocumentEventActions =
    | 'ELEMENT_VISIBLE'
    | 'PRESS_CAMERA_BUTTON'
    | 'PRESS_FILE_BUTTON'
    | 'PRESS_RETRY_BUTTON'
    | 'PRESS_SKIP_BUTTON'
    | 'PRESS_CAPTURE_BUTTON'
    | 'PRESS_CHANGE_CAMERA_BUTTON'
    | 'PRESS_MIRRORING_BUTTON'
    | 'PRESS_CONNECT_BUTTON'
    | 'PRESS_DISCONNECT_BUTTON'
    | 'PRESS_AUTOSCAN_BUTTON'
    | 'PRESS_PROCESS_BUTTON'
    | 'NEW_PAGE_AVAILABLE'
    | 'NEW_PAGE_STARTED'
    | 'CLOSE'
    | 'CAMERA_PROCESS_CLOSED'
    | 'CAMERA_PROCESS_STARTED'
    | 'VIDEO_STARTED'
    | 'VIDEO_STOPPED'
    | 'FILE_PROCESS_STARTED'
    | 'PROCESS_STARTED'
    | 'PROCESS_FINISHED'
    | 'SERVICE_INITIALIZED';

type Locales =
    | 'ru'
    | 'en'
    | 'de'
    | 'pl'
    | 'it'
    | 'hu'
    | 'zh'
    | 'sk'
    | 'uk'
    | 'fr'
    | 'es'
    | 'pt'
    | 'ar'
    | 'nl'
    | 'id'
    | 'vi'
    | 'ko'
    | 'ms'
    | 'ro'
    | 'el'
    | 'tr'
    | 'ja'
    | 'cs'
    | 'th'
    | 'hi'
    | 'bn'
    | 'he'
    | 'fi'
    | 'sv'
    | 'da'
    | 'hr'
    | 'no'
    | string;

type InternalScenarios =
    | 'MrzAndLocate'
    | 'MrzOrLocate'
    | 'Mrz'
    | 'Locate'
    | 'Barcode'
    | 'MrzOrBarcode'
    | 'BarcodeAndLocate';

type CaptureMode = 'auto' | 'captureVideo' | 'captureFrame';

type FrameShapeType = 'line' | 'corners';

type FrameLineCap = 'butt' | 'round' | 'square';

type CameraMode = 'user' | 'environment';

type DocumentReaderResponseType = Response & { TransactionInfo?: TransactionInfo };
type CameraSnapshotResponseType = Array<{ raw: string; mimeType: string }>;

declare enum ResponseCode {
    EMPTY = -1,
    ERROR = 0,
    OK = 1,
    TIMEOUT = 2,
}

interface CustomEventDataType<R> {
    status: ResponseCode;
    details?: unknown;
    reason?: ErrorTypes;
    response?: R;
    video?: VideoData;
}

interface DetailEvent<A, R> {
    action: A;
    data: CustomEventDataType<R> | null;
}

interface ImageInputParamType {
    frameBottom: number;
    frameLeft: number;
    frameRight: number;
    frameTop: number;
    light: number;
    resolutionType: number;
}

type CaptureFrameType = {
    imageData: Array<ImageData>;
    raw: string;
    mimeType: string;
};

type CaptureType = Array<Omit<CaptureFrameType, 'imageData'>>;

interface DocumentReaderImage {
    data: string;
    light: number;
    pageIdx: number;
}

interface WidthAndHeight {
    width: number;
    height: number;
}

type Resolution = Partial<WidthAndHeight>;

interface StreamParams {
    cameraMode: CameraMode;
    preferredCameraId: string;
    resolution: Resolution;
}

interface VideoData {
    data: Blob;
    mimeType: string;
}

interface VideoRecordSettings {
    delay?: number;
    duration?: number;
}

interface TransactionInfo {
    tag: string;
    transactionId: string;
}

interface PackageParams {
    sizeBytes: number;
    dataName: string;
    metadata?: Record<string, any>;
}

interface DocumentReaderProcessParam {
    returnPackageForReprocess?: boolean;
    returnUncroppedImage?: boolean;
    scenario?: InternalScenarios;
    multipageProcessing?: boolean;
    timeout?: number;
    log?: boolean;
    timeoutFromFirstDetect?: number;
    timeoutFromFirstDocType?: number;
    resultTypeOutput?: Array<Result>;
    customParams?: Record<string, object>;
    imageOutputMaxHeight?: number;
    imageOutputMaxWidth?: number;
    fieldTypesFilter?: Array<TextFieldType>;
    dateFormat?: string;
    measureSystem?: MeasureSystem;
    imageDpiOutMax?: number;
    alreadyCropped?: boolean;
    fastDocDetect?: boolean;
    updateOCRValidityByGlare?: boolean;
    returnCroppedBarcode?: boolean;
    respectImageQuality?: boolean;
    forceDocFormat?: DocumentFormat;
    noGraphics?: boolean;
    documentAreaMin?: number;
    depersonalizeLog?: boolean;
    multiDocOnImage?: boolean;
    shiftExpiryDate?: number;
    minimalHolderAge?: number;
    mrzFormatsFilter?: Array<MRZFormat>;
    forceReadMrzBeforeLocate?: boolean;
    parseBarcodes?: boolean;
    splitNames?: boolean;
    imageQa?: {
        expectedPass?: Array<string>;
        dpiThreshold?: number;
        glaresCheck?: boolean;
        glaresCheckParams?: {
            imgMarginPart?: number;
            maxGlaringPart?: number;
        };
    };
    backendProcessing?: {
        serviceURL?: string;
        httpHeaders?: Record<string, string>;
    };
}

interface NewTransaction {
    ContainerList: ContainerList;
    TransactionInfo: {
        ComputerName: string;
        DateTime: string;
        SystemInfo: string;
        Tag: string;
        TransactionID: string;
    };
    sessionLogFolder: string;
}

interface ProcessingRequest {
    metadata?: Record<string, any>;
    tag?: string;
    processParam: DocumentReaderProcessParam;
    imagesList?: Array<DocumentReaderImage>;
    imageInputParam?: ImageInputParamType;
}

interface ImageProcessingRequest {
    tag?: string;
    imageInputParam?: ImageInputParamType;
    processParam: Pick<
        DocumentReaderProcessParam,
        'returnPackageForReprocess' | 'returnUncroppedImage' | 'scenario' | 'backendProcessing'
    >;
}

interface CurrentPage {
    data: Response | null;
    startNextPage: () => Promise<void>;
    finishRecognition: () => void;
}

interface DocumentTranslations {
    scanIDInBrowser?: string;
    useYourDeviceCamera?: string;
    success?: string;
    processingFinished?: string;
    largeFile?: string;
    selectSmallerFile?: string;
    versionNotSupported?: string;
    updateBrowser?: string;
    licenseError?: string;
    licenseExpired?: string;
    fileCorrupt?: string;
    selectAnotherFile?: string;
    timeout?: string;
    error?: string;
    somethingWentWrong?: string;
    tryAgain?: string;
    fromCamera?: string;
    fromGallery?: string;
    processing?: string;
    preparingService?: string;
    placeDocumentIntoFrame?: string;
    positionDocumentCenter?: string;
    noFocus?: string;
    moveCloser?: string;
    glaresOnDocument?: string;
    holdDocumentStraight?: string;
    documentProcessing?: string;
    flipDocument?: string;
    cameraUnavailable?: string;
    preparingCamera?: string;
    noCameraAvailable?: string;
    incorrectCameraId?: string;
    allowAccessToCamera?: string;
    cameraConnection?: string;
    checkCameraId?: string;
    photoCapturedSuccessfully?: string;
    uploadPhoto?: string;
    useCameraOrGallery?: string;
    connect?: string;
    disconnect?: string;
    process?: string;
    device?: string;
    service?: string;
    autoScan?: string;
    keepDeviceStill?: string;
}

interface CameraSnapshotSettings {
    startScreen?: boolean;
    locale?: Locales | string;
    multipleFileInput?: boolean;
    regulaLogo?: boolean;
    cameraId?: string;
    changeCameraButton?: boolean;
    closeButton?: boolean;
    resolution?: Resolution;
    cameraMode?: CameraMode;
    nonce?: string;
    statusTextColor?: string;
    statusBackgroundColor?: string;
}

interface DocumentReaderSettings extends CameraSnapshotSettings {
    internalScenario?: InternalScenarios | string;
    multipageProcessing?: boolean;
    devLicense?: string;
    captureButton?: boolean;
    captureMode?: CaptureMode;
    flipFrontIcon?: string;
    flipBackIcon?: string;
    skipButton?: boolean;
    cameraFrameBorderWidth?: number;
    backgroundMaskAlpha?: number;
    cameraFramePortraitAspectRatio?: number;
    cameraFrameLandscapeAspectRatio?: number;
    statusPositionMultiplier?: number;
    statusIcon?: boolean;
    cameraFrameOffsetWidth?: number;
    cameraFrameVerticalPositionMultiplier?: number;
    cameraFrameShapeType?: FrameShapeType;
    cameraFrameLineCap?: FrameLineCap;
    cameraFrameLineLength?: number;
    cameraFrameCornerRadius?: number;
    cameraFrameActiveColor?: string;
    cameraFrameDefaultColor?: string;
    cameraFrame?: boolean;
    captureButtonDelay?: number;
    videoRecord?: boolean | VideoRecordSettings;
    videoCaptureMotionControl?: boolean;
}

type TScenarioParams = {
    name: string;
    desc: string;
    caption: string;
    frameKWHDoublePageSpreadLandscape: string;
    frameKWHDoublePageSpreadPortrait: string;
    frameKWHLandscape: string;
    frameKWHPortrait: string;
    frameOrientation: number;
    barcodeExt?: number;
    faceExt?: number;
    manualCrop?: number;
    multiPageOff?: number;
    seriesProcessMode?: number;
    UVTorch?: number;
};

type DocumentDictionaries = Partial<Record<Locales, DocumentTranslations>>;
type RecognizeListener = (data: Response) => void;
type ResponseListener = (currentPage: CurrentPage) => void;
type PrepareListener = ({ isPrepared }: { isPrepared: boolean }) => void;
type ProcessingListener = ({ isProcessing }: { isProcessing: boolean }) => void;
type InitializeListener = ({ isInitialized }: { isInitialized: boolean }) => void;

declare global {
    interface HTMLElementEventMap {
        'document-reader': CustomEvent<DocumentReaderDetailType>;
        'camera-snapshot': CustomEvent<CameraSnapshotDetailType>;
    }
}

export interface ICameraSnapshot {
    locale?: Locales;
    copyright?: boolean;
    'camera-id'?: string;
    'change-camera'?: boolean;
    'start-screen'?: boolean;
    multiple?: boolean;
    'close-button'?: boolean;
}

export type License = {
    license: {
        errorCode: number;
        message: string;
        status: boolean;
    };
    scenario: Array<TScenarioParams>;
};

export interface IDocumentReader extends ICameraSnapshot {
    'internal-scenario'?: InternalScenarios;
    'multipage-processing'?: boolean;
    license?: string;
    'capture-button'?: boolean;
}

export type DocumentReaderDetailType = DetailEvent<DocumentEventActions, DocumentReaderResponseType>;
export type CameraSnapshotDetailType = DetailEvent<DocumentEventActions, CameraSnapshotResponseType>;

export function defineComponents(): Promise<void>;

export class FullScreenContainer extends HTMLElement {}

export class DocumentReaderWebComponent extends HTMLElement {
    set translations(dictionary: DocumentDictionaries | null);
    get translations(): DocumentDictionaries | null;
    set settings(params: DocumentReaderSettings);
    get settings(): DocumentReaderSettings;
}

export class DocumentReaderCaptureWebComponent extends HTMLElement {
    set translations(dictionary: DocumentDictionaries | null);
    get translations(): DocumentDictionaries | null;
    set settings(params: CameraSnapshotSettings);
    get settings(): CameraSnapshotSettings;
}

export class DocumentReaderProcessor {
    isProcessing: boolean;
    isInitialized: boolean;
    videoElement: HTMLVideoElement | null;
    constructor(videoElement?: HTMLVideoElement);
    get recognizeListener(): RecognizeListener | null;
    set recognizeListener(listener: RecognizeListener | null);
    get streamParam(): Partial<StreamParams>;
    set streamParam(params: Partial<StreamParams>);
    get recognizerProcessParam(): ProcessingRequest;
    set recognizerProcessParam(params: ProcessingRequest);
    get imageProcessParam(): ImageProcessingRequest;
    set imageProcessParam(params: ImageProcessingRequest);
    get workerPath(): string;
    set workerPath(url: string);
    switchCamera(): Promise<void>;
    startRecognition(responseListener?: ResponseListener): Promise<Response | null>;
    processImage(images: FileList | Array<Blob>): Promise<Response>;
    stopRecognition(): void;
    initialize(license?: { license: string | undefined }): Promise<License>;
    shutdown(): void;
}

export class DocumentReaderService {
    isAutoPrepare: boolean;
    isPrepared: boolean;
    isInitialized: boolean;
    isProcessing: boolean;
    initData: License | null;
    recognizerProcessParam: ProcessingRequest;
    imageProcessParam: ImageProcessingRequest;
    recognizeListener: RecognizeListener | null;
    workerPath: string;
    version: { component: string };
    get processingListener(): ProcessingListener | null;
    set processingListener(listener: ProcessingListener | null);
    get prepareListener(): PrepareListener | null;
    set prepareListener(listener: PrepareListener | null);
    get initializeListener(): InitializeListener | null;
    set initializeListener(listener: InitializeListener | null);
    prepare(): Promise<void>;
    initialize(initData?: { license: string | undefined }): Promise<License>;
    processImageBase64(base64ImagesArray: Array<string>, params: ProcessingRequest): Promise<Response>;
    process(imageDataArray: Array<ImageData>, params?: ProcessingRequest): Promise<Response>;
    processImage(imageDataArray: Array<ImageData>, params?: ProcessingRequest): Promise<Response>;
    startNewPage(): Promise<void>;
    startNewDocument(metadata?: Record<string, any>): Promise<NewTransaction>;
    createBackendTransaction(metadata?: Record<string, any>): Promise<NewTransaction>;
    finalizePackage(): Promise<TransactionInfo>;
    addDataToPackage(data: Uint8ClampedArray, params: PackageParams): Promise<void>;
    shutdown(): void;
}
